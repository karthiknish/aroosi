rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { return request.auth != null; }
    function isAdmin() { return isSignedIn() && request.auth.token.admin == true; }
    // Safe version that handles missing conversation docs by checking conversation ID format
    function safeInConversation(convId) {
      let convDoc = get(/databases/$(database)/documents/conversations/$(convId));
      // If conversation doc exists, check membership; otherwise validate based on ID format
      return convDoc.data != null
        ? (request.auth.uid in convDoc.data.participants)
        : (
          convId.split('_').size() == 2 && request.auth.uid in convId.split('_')
        );
    }

    match /users/{userId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && request.auth.uid == userId &&
        // Disallow decreasing completion percentage after creation
        (
          !('profileCompletionPercentage' in request.resource.data) ||
          resource == null ||
          request.resource.data.profileCompletionPercentage >= resource.data.profileCompletionPercentage
        ) &&
  true;
    }

    // Public blog posts: allow anyone to read, block client writes (server uses Admin SDK)
    match /blogPosts/{postId} {
      allow read: if true;
      allow write: if false;
    }

    // Conversations metadata: allow participants to create/read; prevent deletes
    match /conversations/{conversationId} {
      // Create/update allowed if the caller is included in the participants list they are writing
      // and the conversation ID matches the participant format
      allow create, update: if isSignedIn()
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.updatedAt is number
        && request.resource.data.participants.size() == 2
        && (
          // Build expected normalized conversationId without using unsupported sort/join
          (
            (request.resource.data.participants[0] is string) &&
            (request.resource.data.participants[1] is string)
          ) &&
          (
            conversationId == (
              request.resource.data.participants[0] < request.resource.data.participants[1]
                ? (request.resource.data.participants[0] + '_' + request.resource.data.participants[1])
                : (request.resource.data.participants[1] + '_' + request.resource.data.participants[0])
            )
          )
        );
      // Read allowed if the caller is a participant of the conversation
      allow read: if isSignedIn()
        && resource.data.participants is list
        && request.auth.uid in resource.data.participants;
      allow delete: if false;
    }

    match /blocks/{blockId} {
      allow create: if isSignedIn()
        && request.resource.data.blockerId == request.auth.uid
        && request.resource.data.blockedUserId is string
        && request.resource.data.blockedUserId != request.auth.uid;
      allow delete: if isSignedIn() && resource.data.blockerId == request.auth.uid;
      allow read: if isSignedIn() && (
        resource.data.blockerId == request.auth.uid ||
        resource.data.blockedUserId == request.auth.uid
      );
      allow update: if false;
    }

  // Message delivery & read receipts

    // Cached recommendations snapshots - never directly writable by clients
    match /recommendations/{recId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid; // only owner can read
      allow write: if false;
    }

    // Voice messages metadata - restrict to sender/recipient or conversation participants.
    match /voiceMessages/{msgId} {
      // Allow authenticated users to create voice messages they are the sender of
      allow create: if isSignedIn() && request.resource.data.fromUserId == request.auth.uid;

      // Allow reads if the caller is the sender/recipient, or if the message has a conversationId and the caller is a participant of that conversation.
      allow read: if isSignedIn() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid ||
        (resource.data.conversationId is string && safeInConversation(resource.data.conversationId))
      );

      // Prevent client updates/deletes
      allow update: if false;
      allow delete: if false;
    }

    // Fine-grained usage tracking collections - server authored only
    match /usageEvents/{eventId} {
      allow read: if false; // not needed client-side; aggregate endpoints expose needed data
      allow write: if false; // server only
    }
    match /usageMonthly/{docId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid; // allow user to query own aggregates if needed
      allow write: if false; // server only
    }

    match /reports/{reportId} {
      allow create: if isSignedIn() && request.resource.data.reporterUserId == request.auth.uid;
      allow read: if isAdmin() || (isSignedIn() && resource.data.reporterUserId == request.auth.uid);
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Realtime chat messages
    match /messages/{messageId} {
      // Allow authenticated users to create messages they are the sender of.
      allow create: if isSignedIn()
        && request.resource.data.fromUserId == request.auth.uid
        && request.resource.data.conversationId is string
        && request.resource.data.toUserId is string
        && request.resource.data.type in ["text", "voice", "image"]
        && (request.resource.data.text is string || request.resource.data.type != "text")
        && (
          request.resource.data.createdAt is number ||
          request.resource.data.createdAt is timestamp
        )
        // Optional reply metadata (all-or-none basic validation)
        && (
          !('replyToMessageId' in request.resource.data) || (
            request.resource.data.replyToMessageId is string &&
            (!('replyToText' in request.resource.data) || request.resource.data.replyToText is string) &&
            (!('replyToType' in request.resource.data) || request.resource.data.replyToType in ["text", "voice", "image"]) &&
            (!('replyToFromUserId' in request.resource.data) || request.resource.data.replyToFromUserId is string)
          )
        )
        // Optional participants field for easier rule checking
        && (
          !('participants' in request.resource.data) || 
          (request.resource.data.participants is list && request.auth.uid in request.resource.data.participants)
        )
        // Validate conversation ID format matches participants
        && (
          // Build expected normalized ID a_b deterministically without sort/join
          (
            request.resource.data.fromUserId is string &&
            request.resource.data.toUserId is string
          ) &&
          (
            request.resource.data.conversationId == (
              request.resource.data.fromUserId < request.resource.data.toUserId
                ? (request.resource.data.fromUserId + '_' + request.resource.data.toUserId)
                : (request.resource.data.toUserId + '_' + request.resource.data.fromUserId)
            )
          )
        )
    ;

      // Allow participants (sender or recipient) to read messages for their conversation.
      allow read: if isSignedIn() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid ||
        (resource.data.participants is list && request.auth.uid in resource.data.participants) ||
        (resource.data.conversationId is string && safeInConversation(resource.data.conversationId))
      );

      // Allow recipient to mark a message as read by updating only `readAt` to a newer timestamp.
      allow update: if isSignedIn()
        && request.auth.uid == resource.data.toUserId
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(["readAt"]) 
        && (request.resource.data.readAt is number)
    && (resource.data.readAt == null || request.resource.data.readAt >= resource.data.readAt);

      // Prevent client deletes
      allow delete: if false;
    }

    // Message receipts (idempotent per user/message)
    match /messageReceipts/{receiptId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      // Allow the owning user to upsert their receipt (mark delivered/read). Server-only writes remain possible via admin SDK.
      allow create, update: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.messageId is string
        && request.resource.data.status in ["delivered", "read"]
        && request.resource.data.updatedAt is number
        // Ensure receipt ID follows expected format: messageId_userId
        && receiptId == request.resource.data.messageId + '_' + request.auth.uid;
      allow delete: if false;
    }

    // Matches denormalization: allow participants to update lastMessage and updatedAt only
    match /matches/{matchId} {
      allow read: if isSignedIn()
        && (
          request.auth.uid == resource.data.user1Id || 
          request.auth.uid == resource.data.user2Id
        );
      allow update: if isSignedIn()
        && (
          // Either participant can update
          request.auth.uid == resource.data.user1Id || request.auth.uid == resource.data.user2Id
        )
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(["lastMessage", "updatedAt"])
        && request.resource.data.status == resource.data.status; // Don't allow status changes
      allow create, delete: if false;
    }

    // Typing indicators: ephemeral docs under typingIndicators/{conversationId}/users/{userId}
    match /typingIndicators/{conversationId}/users/{userId} {
      // Only the user may write their own typing indicator
      allow create, update: if isSignedIn() && request.auth.uid == userId
        && request.resource.data.isTyping is bool
        && request.resource.data.updatedAt is number;
      // Participants may read typing indicators for their conversation
      allow read: if isSignedIn() && (
  // Allow reading if user is part of the conversation based on conversation ID format
  request.auth.uid in conversationId.split('_') ||
        // Or if conversation document exists and user is a participant
        safeInConversation(conversationId)
      );
      allow delete: if false;
    }

    // VIP Aroosi contact form submissions
    match /vip-contact/{docId} {
  allow create: if true;
      allow read, update, delete: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
