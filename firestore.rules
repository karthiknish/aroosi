rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { return request.auth != null; }
    function isAdmin() { return isSignedIn() && request.auth.token.admin == true; }
    // Check if the current user is a participant in a conversation doc
    function inConversation(convId) {
      return get(/databases/$(database)/documents/conversations/$(convId)).data != null
        && request.auth.uid in get(/databases/$(database)/documents/conversations/$(convId)).data.participants;
    }

    match /users/{userId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && request.auth.uid == userId &&
        // Disallow decreasing completion percentage after creation
        (
          !('profileCompletionPercentage' in request.resource.data) ||
          resource == null ||
          request.resource.data.profileCompletionPercentage >= resource.data.profileCompletionPercentage
        ) &&
  true;
    }

    // Conversations metadata: allow participants to create/read; prevent deletes
    match /conversations/{conversationId} {
      // Create/update allowed if the caller is included in the participants list they are writing
      allow create, update: if isSignedIn()
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.updatedAt is number;
      // Read allowed if the caller is a participant of the conversation
      allow read: if isSignedIn()
        && resource.data.participants is list
        && request.auth.uid in resource.data.participants;
      allow delete: if false;
    }

    match /blocks/{blockId} {
      allow create: if isSignedIn()
        && request.resource.data.blockerId == request.auth.uid
        && request.resource.data.blockedUserId is string
        && request.resource.data.blockedUserId != request.auth.uid;
      allow delete: if isSignedIn() && resource.data.blockerId == request.auth.uid;
      allow read: if isSignedIn() && (
        resource.data.blockerId == request.auth.uid ||
        resource.data.blockedUserId == request.auth.uid
      );
      allow update: if false;
    }

    // Message delivery & read receipts (write server-only: rely on custom backend)
    match /messageReceipts/{receiptId} {
      allow read: if isSignedIn();
      // Deny direct client writes to prevent spoofing; backend uses Admin SDK.
      allow write: if false;
    }

    // Cached recommendations snapshots - never directly writable by clients
    match /recommendations/{recId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid; // only owner can read
      allow write: if false;
    }

    // Voice messages metadata - restrict to sender or participants (simplified: owner write, participants read)
    match /voiceMessages/{msgId} {
      allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid;
      allow read: if isSignedIn() && (
        resource.data.senderId == request.auth.uid ||
        (resource.data.recipientId != null && resource.data.recipientId == request.auth.uid)
      );
      // Prevent updates except maybe status by sender (optional hard deny for now)
      allow update: if false;
      allow delete: if false;
    }

    // Fine-grained usage tracking collections - server authored only
    match /usageEvents/{eventId} {
      allow read: if false; // not needed client-side; aggregate endpoints expose needed data
      allow write: if false; // server only
    }
    match /usageMonthly/{docId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid; // allow user to query own aggregates if needed
      allow write: if false; // server only
    }

    match /reports/{reportId} {
      allow create: if isSignedIn() && request.resource.data.reporterUserId == request.auth.uid;
      allow read: if isAdmin() || (isSignedIn() && resource.data.reporterUserId == request.auth.uid);
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Realtime chat messages
    match /messages/{messageId} {
      // Allow authenticated users to create messages they are the sender of.
      allow create: if isSignedIn()
        && request.resource.data.fromUserId == request.auth.uid
        && request.resource.data.conversationId is string
        && request.resource.data.toUserId is string
        && request.resource.data.type in ["text", "voice", "image"]
        && (request.resource.data.text is string || request.resource.data.type != "text")
        && (
          request.resource.data.createdAt is number ||
          request.resource.data.createdAt is timestamp
        )
        // Optional reply metadata (all-or-none basic validation)
        && (
          !('replyToMessageId' in request.resource.data) || (
            request.resource.data.replyToMessageId is string &&
            (!('replyToText' in request.resource.data) || request.resource.data.replyToText is string) &&
            (!('replyToType' in request.resource.data) || request.resource.data.replyToType in ["text", "voice", "image"]) &&
            (!('replyToFromUserId' in request.resource.data) || request.resource.data.replyToFromUserId is string)
          )
        )
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.banned != true;

      // Allow participants (sender or recipient) to read messages for their conversation.
      allow read: if isSignedIn() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid ||
        (resource.data.participants is list && request.auth.uid in resource.data.participants) ||
        (resource.data.conversationId is string && inConversation(resource.data.conversationId))
      );

      // Allow recipient to mark a message as read by updating only `readAt` to a newer timestamp.
      allow update: if isSignedIn()
        && request.auth.uid == resource.data.toUserId
        && !("text" in request.resource.data)
        && !("fromUserId" in request.resource.data)
        && !("toUserId" in request.resource.data)
        && !("replyToMessageId" in request.resource.data)
        && !("replyToText" in request.resource.data)
        && !("replyToType" in request.resource.data)
        && !("replyToFromUserId" in request.resource.data)
        && (request.resource.data.readAt is number)
        && (resource.data.readAt == null || request.resource.data.readAt >= resource.data.readAt)
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.banned != true;

      // Prevent client deletes
      allow delete: if false;
    }

    // Message receipts (idempotent per user/message)
    match /messageReceipts/{receiptId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      // Allow the owning user to upsert their receipt (mark delivered/read). Server-only writes remain possible via admin SDK.
      allow create, update: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.messageId is string
        && request.resource.data.status in ["delivered", "read"]
        && request.resource.data.updatedAt is number;
      allow delete: if false;
    }

    // Typing indicators: ephemeral docs under typingIndicators/{conversationId}/users/{userId}
    match /typingIndicators/{conversationId}/users/{userId} {
      // Only the user may write their own typing indicator
      allow create, update: if isSignedIn() && request.auth.uid == userId
        && request.resource.data.isTyping is bool
        && request.resource.data.updatedAt is number;
      // Participants may read typing indicators for their conversation (requires a backend check to verify membership if needed).
      allow read: if isSignedIn();
      allow delete: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
